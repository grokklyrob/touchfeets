{"version":3,"sources":["turbopack:///[project]/lib/prisma.ts","turbopack:///[project]/lib/entitlements.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\n/**\n * Prisma singleton for Next.js (avoids hot-reload multiple client instances)\n */\nexport const prisma =\n  globalThis.prisma ??\n  new PrismaClient({\n    log: [\"warn\", \"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalThis.prisma = prisma;\n}\n\nexport default prisma;","import prisma from \"@/lib/prisma\";\n\ntype PlanTier = \"FREE\" | \"BASIC_50\" | \"PLUS_200\" | \"PRO_1000\";\n\n/**\n * Quota and watermark policy per tier.\n * FREE: visible watermark required\n * Paid tiers: watermarkExempt = true (no visible overlay)\n */\nexport const PLAN_DEFAULTS: Record<PlanTier, { monthlyQuota: number; watermarkExempt: boolean }> = {\n  FREE: { monthlyQuota: 5, watermarkExempt: false },\n  BASIC_50: { monthlyQuota: 50, watermarkExempt: true },\n  PLUS_200: { monthlyQuota: 200, watermarkExempt: true },\n  PRO_1000: { monthlyQuota: 1000, watermarkExempt: true },\n};\n\n/**\n * Map from Stripe Price ID (env) to PlanTier.\n * Configure in environment:\n *  - PRICE_ID_BASIC_50\n *  - PRICE_ID_PLUS_200\n *  - PRICE_ID_PRO_1000\n */\nexport function planFromStripePriceId(priceId: string | null | undefined): PlanTier {\n  const basic = process.env.PRICE_ID_BASIC_50;\n  const plus = process.env.PRICE_ID_PLUS_200;\n  const pro = process.env.PRICE_ID_PRO_1000;\n  if (priceId && basic && priceId === basic) return \"BASIC_50\";\n  if (priceId && plus && priceId === plus) return \"PLUS_200\";\n  if (priceId && pro && priceId === pro) return \"PRO_1000\";\n  return \"FREE\";\n}\n\n/**\n * Format current month in UTC as YYYY-MM\n */\nexport function monthUtc(date = new Date()): string {\n  const y = date.getUTCFullYear();\n  const m = (date.getUTCMonth() + 1).toString().padStart(2, \"0\");\n  return `${y}-${m}`;\n}\n\n/**\n * Ensure a quota row exists for the user for the given month.\n */\nexport async function getOrCreateQuota(userId: string, month = monthUtc()) {\n  let q = await prisma.quota.findUnique({\n    where: { userId_monthUtc: { userId, monthUtc: month } },\n  });\n  if (!q) {\n    q = await prisma.quota.create({\n      data: {\n        userId,\n        monthUtc: month,\n        freeRemaining: PLAN_DEFAULTS[\"FREE\"].monthlyQuota,\n        paidRemaining: 0,\n        watermarkExempt: false,\n      },\n    });\n  }\n  return q;\n}\n\n/**\n * Update user entitlements when subscription status/price changes.\n * Called from Stripe webhook handlers for checkout.session.completed,\n * customer.subscription.updated, customer.subscription.deleted, invoice.payment_failed, etc.\n *\n * Behavior:\n * - If active subscription with a recognized price:\n *    - Set tier to mapped tier; set paidRemaining to full tier quota for current month.\n *    - watermarkExempt = true for paid tiers.\n * - If no active subscription:\n *    - Revert to FREE: keep or reset freeRemaining (up to default), set paidRemaining = 0, watermarkExempt = false.\n *\n * Note: This function sets the \"starting point\" for the current month. Decrements occur per-generation elsewhere.\n */\nexport async function applyEntitlementsForSubscription(opts: {\n  userId: string;\n  status: \"trialing\" | \"active\" | \"past_due\" | \"canceled\" | \"unpaid\" | \"incomplete\" | \"incomplete_expired\" | \"paused\" | string;\n  stripeCustomerId?: string | null;\n  stripeSubscriptionId?: string | null;\n  stripePriceId?: string | null;\n  currentPeriodStart?: Date | null;\n  currentPeriodEnd?: Date | null;\n  anchorUtcDay?: number | null;\n}) {\n  const {\n    userId,\n    status,\n    stripeCustomerId,\n    stripeSubscriptionId,\n    stripePriceId,\n    currentPeriodStart,\n    currentPeriodEnd,\n    anchorUtcDay,\n  } = opts;\n\n  const tier = status === \"active\" || status === \"trialing\"\n    ? planFromStripePriceId(stripePriceId)\n    : \"FREE\";\n\n  // Upsert subscription record (metadata for audit)\n  await prisma.subscription.upsert({\n    where: { stripeSubscriptionId: stripeSubscriptionId ?? \"\" },\n    update: {\n      userId,\n      status,\n      planTier: tier,\n      stripeCustomerId: stripeCustomerId ?? undefined,\n      stripePriceId: stripePriceId ?? undefined,\n      currentPeriodStart: currentPeriodStart ?? undefined,\n      currentPeriodEnd: currentPeriodEnd ?? undefined,\n      anchorUtcDay: anchorUtcDay ?? undefined,\n    },\n    create: {\n      userId,\n      status,\n      planTier: tier,\n      stripeCustomerId: stripeCustomerId ?? undefined,\n      stripeSubscriptionId: stripeSubscriptionId ?? undefined,\n      stripePriceId: stripePriceId ?? undefined,\n      currentPeriodStart: currentPeriodStart ?? undefined,\n      currentPeriodEnd: currentPeriodEnd ?? undefined,\n      anchorUtcDay: anchorUtcDay ?? undefined,\n    },\n  });\n\n  // Bring quotas in sync for current month\n  const m = monthUtc();\n  const q = await getOrCreateQuota(userId, m);\n\n  if (tier === \"FREE\") {\n    // Revert to free entitlements\n    const targetFree = PLAN_DEFAULTS[\"FREE\"].monthlyQuota;\n    await prisma.quota.update({\n      where: { id: q.id },\n      data: {\n        // If user already used some free; do not increase above monthly default\n        freeRemaining: Math.min(q.freeRemaining ?? 0, targetFree),\n        paidRemaining: 0,\n        watermarkExempt: false,\n      },\n    });\n  } else {\n    const { monthlyQuota, watermarkExempt } = PLAN_DEFAULTS[tier];\n    await prisma.quota.update({\n      where: { id: q.id },\n      data: {\n        // Preserve remaining free, add paidRemaining fresh for the month anchor\n        paidRemaining: monthlyQuota,\n        watermarkExempt,\n      },\n    });\n  }\n\n  // Audit log\n  await prisma.auditLog.create({\n    data: {\n      userId,\n      action: \"ENTITLEMENTS_SYNC\",\n      contextJson: {\n        status,\n        stripeCustomerId,\n        stripeSubscriptionId,\n        stripePriceId,\n        resolvedTier: tier,\n        month: m,\n      },\n    },\n  });\n\n  return { tier };\n}\n\n/**\n * Decrement quota for a generation attempt. This is called from the generate route.\n * - Paid users consume from paidRemaining. When it's 0, fallback to freeRemaining if available (still watermarked=false as long as watermarkExempt is true).\n * - Free users consume from freeRemaining only. If 0, reject upstream.\n */\nexport async function decrementQuota(userId: string) {\n  const m = monthUtc();\n  const q = await getOrCreateQuota(userId, m);\n\n  if (q.paidRemaining > 0) {\n    return prisma.quota.update({\n      where: { id: q.id },\n      data: { paidRemaining: { decrement: 1 } },\n    });\n  }\n\n  if (q.freeRemaining > 0) {\n    return prisma.quota.update({\n      where: { id: q.id },\n      data: { freeRemaining: { decrement: 1 } },\n    });\n  }\n\n  throw new Error(\"Quota exceeded for the current month\");\n}\n\n/**\n * Helper to check whether visible watermark overlay should be applied.\n */\nexport async function isWatermarkExempt(userId: string) {\n  const q = await prisma.quota.findFirst({\n    where: { userId, monthUtc: monthUtc() },\n    select: { watermarkExempt: true },\n  });\n  return q?.watermarkExempt ?? false;\n}"],"names":[],"mappings":"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"}